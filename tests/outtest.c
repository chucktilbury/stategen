
// BEGINNING OF C SUPPORT ROUTINES

/*
 *  Generic scanner module.  This module breaks input up into groups of
 *  characters.  It does not attempt to attach any meaning or value to them.
 *
 *  1.  Requires a list of "stop" characters, usually white space.  These are
 *      actually single character token that are not returned by the scanner.
 *      This includes the \n character, which is used to indicate the end of a
 *      line.
 *
 *  2.  A list of characters that are part of a simple token that are special
 *      somehow.  For example, the tokens "%{", "%}", "==", "!=", ">=", and
 *      "<=" are composed of the string "%{}=!<>".  If the string "%=!" is
 *      encountered in the input, then it will be returned.
 *
 *  3.  Requires a list of characters that can appear within words.  The term
 *      "word" is in the most generic sense.  In this context a string that
 *      represents a number is a word, too.
 *
 *  4.  A list of quote characters.  Normally, this will be "\"\'", but it
 *      could be anything.  These are considered "stop" characters and are
 *      treated as a string.  The quote character is returned with the string.
 *
 *  Any character that is encountered in the input that is not in one of these
 *  4 lists is considered an error.
 *
 *  This scanner is hard wired to ignore C comments and to return everything
 *  between a "%{" and a "%}" as a raw code block.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "../files.h"

// Globals used by the support routines to maintain state that is not part of
// the state machine.
static unsigned int char_table[256];
static char buffer[1024*64];
static int index;
static int character;

// arrays of characters that define different transitions for read_trans()
static const char *stop = " \t\r\n";
static const char *special = "~!@#$^()-=+|\\[]:;<>,.?&"; // "%/*{}"  &
static const char *words = "0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

// these are values that could be defined by read_trans().
enum {
    INVALID = 0,// an invalid character
    WHITE,      // spaces tabs and line endings
    ALPNUM,     // alphanumeric characters
    NEWLINE,    // used to end a single line comment
    PUNCT,      // characters such as #,$, and @
    SQCHAR,     // the \' char
    DQCHAR,     // the \" char
    PERCENT,    // the % char
    SLASH,      // the / char
    STAR,       // the * char
    OCURLY,     // the { char
    CCURLY,     // the } char
    END_FILE,   // the EOF char
};

static int read_trans(void) {

    character = read_character();
    return char_table[character];
}

static void nop(void) {
    // its an easy one....
}

static void invalid_char(void) {
    fprintf(stderr, "SCAN ERROR: invalid character '%c' encountered in \"%s\" on line %d\n",
            character, file_name(), line_number());
}

static void unexpected_newline(void) {
    fprintf(stderr, "SCAN ERROR: unexpected newline encountered in \"%s\" on line %d\n",
            file_name(), line_number());
}

static void unexpected_eof(void) {
    fprintf(stderr, "SCAN ERROR: unexpected end of file encountered in \"%s\" on line %d\n",
            file_name(), line_number());
}

static void unexpected_ccurly(void) {
    fprintf(stderr, "SCAN ERROR: unexpected \'}\' encountered in \"%s\" on line %d\n",
            file_name(), line_number());
}

static void copy_char(void) {
    buffer[index++] = character;
}

static void pushback(void) {
    unread_character(character);
}

static void init_rawblock(void) {
    index = 0;
    memset(buffer, 0, sizeof(buffer));
    buffer[index++] = '%';
    buffer[index++] = '{';
}

static void init_copy(void) {
    index = 0;
    memset(buffer, 0, sizeof(buffer));
    buffer[index++] = character;
}

static void init_block(void) {
    buffer[index++] = character;
}

// END OF C SUPPORT ROUTINES

///////////////////////////////////////////////
// machine definitions will be inserted here.
///////////////////////////////////////////////
/*******************************************************************************
*  Generated code below this point
******************************************************************************/

typedef struct {
    int state;
    void (*func)(void);
} state_t;

enum {
    END = 10000,
    ERROR,
};
// inline code definitions generated by software
static void _0000(void) {
 copy_char(); 
}

static void _0001(void) {

            int ploo =0, blart = 1;
            while(blart) {
                nop();
                if(ploo) {
                    printf("a floop of blart");
                }
            }
        
}

// end of inline code definitions
//#define DEBUGGING

#ifdef DEBUGGING
#define func_to_strg(func) ( \
                   (func == _0001)? "_0001": \
                   (func == Word)? "Word": \
                   (func == Squote)? "Squote": \
                   (func == Dquote)? "Dquote": \
                   (func == RawBlock)? "RawBlock": \
                   (func == unexpected_ccurly)? "unexpected_ccurly": \
                   (func == Mline)? "Mline": \
                   (func == Sline)? "Sline": \
                   (func == invalid_char)? "invalid_char": \
                   (func == pushback)? "pushback": \
                   (func == InlineBlock)? "InlineBlock": \
                   (func == init_rawblock)? "init_rawblock": \
                   (func == _0000)? "_0000": \
                   (func == init_block)? "init_block": \
                   (func == Block)? "Block": \
                   (func == unexpected_eof)? "unexpected_eof": \
                   (func == unexpected_newline)? "unexpected_newline": \
                   (func == init_copy)? "init_copy": \
                   (func == read_trans)? "read_trans": \
                   (func == nop)? "nop": \
                   (func == copy_char)? "copy_char": \
 "UNKNOWN")


#define RUN_STATE(reader, table) int state = START; \
    printf("\nSM %s() ENTER\n", __func__); \
    do{ \
        int trans = reader(); \
        printf("state = %s: trans = %s: char = '%c' (0x%02X) => func: %s state: %s\n", \
                state_names[state], trans_names[trans], \
                (character == 0x0a)? ' ': character, character, \
                func_to_strg(table[state][trans].func), state_names[table[state][trans].state]); \
        (*table[state][trans].func)(); \
        state = table[state][trans].state; \
    }while(state != END && state != ERROR); \
    printf("SM %s() RETURNING\n", __func__)

#else
#define RUN_STATE(reader, table) int state = START; \
    do{ \
        int trans = reader(); \
        (*table[state][trans].func)(); \
        state = table[state][trans].state; \
    }while(state != END && state != ERROR)
#endif

// Function protos
static void Word(void);
static void Squote(void);
static void Dquote(void);
static void Sline(void);
static void Mline(void);
static void InlineBlock(void);
static void Block(void);
static void RawBlock(void);
static void Scanner(void);


static void Word(void) {
    enum { START, };
    enum { END_FILE, CCURLY, OCURLY, STAR, SLASH, PERCENT, DQCHAR, SQCHAR, PUNCT, NEWLINE, ALPNUM, WHITE, INVALID, };
#ifdef DEBUGGING
char state_names[] = {"START"};
char trans_names[] = {"END_FILE", "CCURLY", "OCURLY", "STAR", "SLASH", "PERCENT", "DQCHAR", "SQCHAR", "PUNCT", "NEWLINE", "ALPNUM", "WHITE", "INVALID"};
#endif

    state_t Word_states[1][13] = {
        {{END, nop}, {END, nop}, {END, nop}, {END, nop}, {END, nop}, {END, nop}, {END, nop}, {END, nop}, {END, nop}, {END, nop}, {START, copy_char}, {END, nop}, {END, nop}}
    };


    init_copy();
    RUN_STATE(read_trans, Word_states);
}


static void Squote(void) {
    enum { START, };
    enum { END_FILE, CCURLY, OCURLY, STAR, SLASH, PERCENT, DQCHAR, SQCHAR, PUNCT, NEWLINE, ALPNUM, WHITE, INVALID, };
#ifdef DEBUGGING
char state_names[] = {"START"};
char trans_names[] = {"END_FILE", "CCURLY", "OCURLY", "STAR", "SLASH", "PERCENT", "DQCHAR", "SQCHAR", "PUNCT", "NEWLINE", "ALPNUM", "WHITE", "INVALID"};
#endif

    state_t Squote_states[1][13] = {
        {{ERROR, unexpected_eof}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {END, copy_char}, {START, copy_char}, {ERROR, unexpected_newline}, {START, copy_char}, {START, copy_char}, {START, copy_char}}
    };


    init_copy();
    RUN_STATE(read_trans, Squote_states);
}


static void Dquote(void) {
    enum { START, };
    enum { END_FILE, CCURLY, OCURLY, STAR, SLASH, PERCENT, DQCHAR, SQCHAR, PUNCT, NEWLINE, ALPNUM, WHITE, INVALID, };
#ifdef DEBUGGING
char state_names[] = {"START"};
char trans_names[] = {"END_FILE", "CCURLY", "OCURLY", "STAR", "SLASH", "PERCENT", "DQCHAR", "SQCHAR", "PUNCT", "NEWLINE", "ALPNUM", "WHITE", "INVALID"};
#endif

    state_t Dquote_states[1][13] = {
        {{ERROR, unexpected_eof}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {END, copy_char}, {START, copy_char}, {START, copy_char}, {ERROR, unexpected_newline}, {START, copy_char}, {START, copy_char}, {START, copy_char}}
    };


    init_copy();
    RUN_STATE(read_trans, Dquote_states);
}


static void Sline(void) {
    enum { START, };
    enum { END_FILE, CCURLY, OCURLY, STAR, SLASH, PERCENT, DQCHAR, SQCHAR, PUNCT, NEWLINE, ALPNUM, WHITE, INVALID, };
#ifdef DEBUGGING
char state_names[] = {"START"};
char trans_names[] = {"END_FILE", "CCURLY", "OCURLY", "STAR", "SLASH", "PERCENT", "DQCHAR", "SQCHAR", "PUNCT", "NEWLINE", "ALPNUM", "WHITE", "INVALID"};
#endif

    state_t Sline_states[1][13] = {
        {{END, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {END, nop}, {START, nop}, {START, nop}, {START, nop}}
    };

    RUN_STATE(read_trans, Sline_states);
}


static void Mline(void) {
    enum { START, HAVESTAR, };
    enum { END_FILE, CCURLY, OCURLY, STAR, SLASH, PERCENT, DQCHAR, SQCHAR, PUNCT, NEWLINE, ALPNUM, WHITE, INVALID, };
#ifdef DEBUGGING
char state_names[] = {"START", "HAVESTAR"};
char trans_names[] = {"END_FILE", "CCURLY", "OCURLY", "STAR", "SLASH", "PERCENT", "DQCHAR", "SQCHAR", "PUNCT", "NEWLINE", "ALPNUM", "WHITE", "INVALID"};
#endif

    state_t Mline_states[2][13] = {
        {{ERROR, unexpected_eof}, {START, nop}, {START, nop}, {HAVESTAR, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}},
        {{ERROR, unexpected_eof}, {START, nop}, {START, nop}, {START, nop}, {END, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}}
    };

    RUN_STATE(read_trans, Mline_states);
}


static void InlineBlock(void) {
    enum { START, HAVECCURLY, };
    enum { END_FILE, CCURLY, OCURLY, STAR, SLASH, PERCENT, DQCHAR, SQCHAR, PUNCT, NEWLINE, ALPNUM, WHITE, INVALID, };
#ifdef DEBUGGING
char state_names[] = {"START", "HAVECCURLY"};
char trans_names[] = {"END_FILE", "CCURLY", "OCURLY", "STAR", "SLASH", "PERCENT", "DQCHAR", "SQCHAR", "PUNCT", "NEWLINE", "ALPNUM", "WHITE", "INVALID"};
#endif

    state_t InlineBlock_states[2][13] = {
        {{ERROR, unexpected_eof}, {HAVECCURLY, copy_char}, {START, Block}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}},
        {{ERROR, unexpected_eof}, {END, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}}
    };

    RUN_STATE(read_trans, InlineBlock_states);
}


static void Block(void) {
    enum { START, };
    enum { END_FILE, CCURLY, OCURLY, STAR, SLASH, PERCENT, DQCHAR, SQCHAR, PUNCT, NEWLINE, ALPNUM, WHITE, INVALID, };
#ifdef DEBUGGING
char state_names[] = {"START"};
char trans_names[] = {"END_FILE", "CCURLY", "OCURLY", "STAR", "SLASH", "PERCENT", "DQCHAR", "SQCHAR", "PUNCT", "NEWLINE", "ALPNUM", "WHITE", "INVALID"};
#endif

    state_t Block_states[1][13] = {
        {{ERROR, unexpected_eof}, {END, copy_char}, {START, Block}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}}
    };


    init_block();
    RUN_STATE(read_trans, Block_states);
}


static void RawBlock(void) {
    enum { START, SQUOTE, MQUOTE, HAVESTAR, SLINE, MLINE, HAVESLASH, HAVEPERCENT, };
    enum { END_FILE, CCURLY, OCURLY, STAR, SLASH, PERCENT, DQCHAR, SQCHAR, PUNCT, NEWLINE, ALPNUM, WHITE, INVALID, };
#ifdef DEBUGGING
char state_names[] = {"START", "SQUOTE", "MQUOTE", "HAVESTAR", "SLINE", "MLINE", "HAVESLASH", "HAVEPERCENT"};
char trans_names[] = {"END_FILE", "CCURLY", "OCURLY", "STAR", "SLASH", "PERCENT", "DQCHAR", "SQCHAR", "PUNCT", "NEWLINE", "ALPNUM", "WHITE", "INVALID"};
#endif

    state_t RawBlock_states[8][13] = {
        {{ERROR, unexpected_eof}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {HAVESLASH, _0000}, {HAVEPERCENT, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}},
        {{ERROR, unexpected_eof}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {START, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}},
        {{ERROR, unexpected_eof}, {MQUOTE, copy_char}, {MQUOTE, copy_char}, {MQUOTE, copy_char}, {MQUOTE, copy_char}, {MQUOTE, copy_char}, {START, copy_char}, {MQUOTE, copy_char}, {MQUOTE, copy_char}, {MQUOTE, copy_char}, {MQUOTE, copy_char}, {MQUOTE, copy_char}, {MQUOTE, copy_char}},
        {{ERROR, unexpected_eof}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {START, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}},
        {{ERROR, unexpected_eof}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {START, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}},
        {{ERROR, unexpected_eof}, {MLINE, copy_char}, {MLINE, copy_char}, {HAVESTAR, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}},
        {{ERROR, unexpected_eof}, {START, copy_char}, {START, copy_char}, {MLINE, copy_char}, {SLINE, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}},
        {{ERROR, unexpected_eof}, {END, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}}
    };


    init_rawblock();
    RUN_STATE(read_trans, RawBlock_states);
}


static void Scanner(void) {
    enum { START, HAVEOCURLY, HAVESLASH, HAVEPERCENT, SPECIAL, };
    enum { END_FILE, CCURLY, OCURLY, STAR, SLASH, PERCENT, DQCHAR, SQCHAR, PUNCT, NEWLINE, ALPNUM, WHITE, INVALID, };
#ifdef DEBUGGING
char state_names[] = {"START", "HAVEOCURLY", "HAVESLASH", "HAVEPERCENT", "SPECIAL"};
char trans_names[] = {"END_FILE", "CCURLY", "OCURLY", "STAR", "SLASH", "PERCENT", "DQCHAR", "SQCHAR", "PUNCT", "NEWLINE", "ALPNUM", "WHITE", "INVALID"};
#endif

    state_t Scanner_states[5][13] = {
        {{END, nop}, {SPECIAL, copy_char}, {HAVEOCURLY, copy_char}, {SPECIAL, copy_char}, {HAVESLASH, copy_char}, {HAVEPERCENT, copy_char}, {END, Dquote}, {END, Squote}, {SPECIAL, copy_char}, {START, _0001}, {END, Word}, {START, _0001}, {ERROR, invalid_char}},
        {{END, nop}, {END, pushback}, {END, InlineBlock}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, nop}, {ERROR, invalid_char}},
        {{END, nop}, {END, pushback}, {END, pushback}, {START, Mline}, {START, Sline}, {SPECIAL, copy_char}, {END, pushback}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {END, pushback}, {END, nop}, {ERROR, invalid_char}},
        {{END, nop}, {ERROR, unexpected_ccurly}, {END, RawBlock}, {SPECIAL, copy_char}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {END, pushback}, {END, nop}, {ERROR, invalid_char}},
        {{END, nop}, {END, pushback}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {END, pushback}, {END, nop}, {ERROR, invalid_char}}
    };


    init_copy();
    RUN_STATE(read_trans, Scanner_states);
}



// End of generated code

// START OF GLOBAL INTERFACE

int init_scanner(void) {

    int i;

    for(i = 0; i < sizeof(char_table); i++)
        char_table[i] = INVALID;

    for(i = 0; stop[i] != 0; i++)
        char_table[(int)stop[i]] = WHITE;      // AKA whitespace

    for(i = 0; special[i] != 0; i++)
        char_table[(int)special[i]] = PUNCT;   // not stoppers or words

    for(i = 0; words[i] != 0; i++)
        char_table[(int)words[i]] = ALPNUM;       // not stoppers or special

    char_table['\"'] = DQCHAR;
    char_table['\''] = SQCHAR;
    char_table['%'] = PERCENT;
    char_table['/'] = SLASH;
    char_table['*'] = STAR;
    char_table['{'] = OCURLY;
    char_table['}'] = CCURLY;
    char_table['\n'] = NEWLINE;
    char_table[255] = END_FILE;

    return 0;
}

void destroy_scanner(void) {
    while(!files_close()) {/*empty*/;}
}

int scanner_open_file(char *name) {
    return files_open(name);
}

int get_word(void) {
    memset(buffer, 0, sizeof(buffer));
    index = 0;
    Scanner();  // this is the name of the primary state machine
    return strlen(buffer);
}

// END OF GLOBAL INTERFACE
