
// BEGINNING OF C SUPPORT ROUTINES

/*
 *  Generic scanner module.  This module breaks input up into groups of
 *  characters.  It does not attempt to attach any meaning or value to them.
 *
 *  1.  Requires a list of "stop" characters, usually white space.  These are
 *      actually single character token that are not returned by the scanner.
 *      This includes the \n character, which is used to indicate the end of a
 *      line.
 *
 *  2.  A list of characters that are part of a simple token that are special
 *      somehow.  For example, the tokens "%{", "%}", "==", "!=", ">=", and
 *      "<=" are composed of the string "%{}=!<>".  If the string "%=!" is
 *      encountered in the input, then it will be returned.
 *
 *  3.  Requires a list of characters that can appear within words.  The term
 *      "word" is in the most generic sense.  In this context a string that
 *      represents a number is a word, too.
 *
 *  4.  A list of quote characters.  Normally, this will be "\"\'", but it
 *      could be anything.  These are considered "stop" characters and are
 *      treated as a string.  The quote character is returned with the string.
 *
 *  Any character that is encountered in the input that is not in one of these
 *  4 lists is considered an error.
 *
 *  This scanner is hard wired to ignore C comments and to return everything
 *  between a "%{" and a "%}" as a raw code block.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "files.h"
#include "errors.h"

// Globals used by the support routines to maintain state that is not part of
// the state machine.
static unsigned int char_table[256];
static char buffer[1024*64];
static int scan_index;
static int character;

// arrays of characters that define different transitions for read_trans()
static const char *stop = " \t\r\n";
static const char *special = "~!@#$^()-=+|\\[]:;<>,.?&"; // "%/*{}"  &
static const char *words = "0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

// these are values that could be defined by read_trans().
enum {
    INVALID = 0,// an invalid character
    WHITE,      // spaces tabs and line endings
    ALPNUM,     // alphanumeric characters
    NEWLINE,    // used to end a single line comment
    PUNCT,      // characters such as #,$, and @
    SQCHAR,     // the \' char
    DQCHAR,     // the \" char
    PERCENT,    // the % char
    SLASH,      // the / char
    STAR,       // the * char
    OCURLY,     // the { char
    CCURLY,     // the } char
    END_FILE,   // the EOF char
};

static int read_trans(void) {

    character = read_character();
    return char_table[character];
}

static int nop(void) {
    // its an easy one....
    return 0; // !0 causes the state machine driver to abort with an error.
}

static int invalid_char(void) {
    SERROR(SCAN_ERROR, "Invalid character '%c' (0x%02X) encountered", character, character);
    return 0;
}

static int unexpected_newline(void) {
    SERROR(SCAN_ERROR, "Unexpected newline encountered");
    return 0;
}

static int unexpected_eof(void) {
    SERROR(SCAN_ERROR, "Unexpected end of file encountered");
    return 0;
}

static int unexpected_ccurly(void) {
    SERROR(SCAN_ERROR, "Unexpected \'}\' encountered");
    return 0;
}

static int copy_char(void) {
    buffer[scan_index++] = character;
    return 0;
}

static int pushback(void) {
    unread_character(character);
    return 0;
}

static int init_copy(void) {
    scan_index = 0;
    memset(buffer, 0, sizeof(buffer));
    buffer[scan_index++] = character;
    return 0;
}

static int post_comment(void) {
    scan_index = 0;
    memset(buffer, 0, sizeof(buffer));
    return 0;
}


// END OF C SUPPORT ROUTINES

///////////////////////////////////////////////
// machine definitions will be inserted here.
///////////////////////////////////////////////
/*******************************************************************************
*  Generated code below this point
******************************************************************************/

typedef struct {
    int state;
    int (*func)(void);
} state_t;

//#define DEBUGGING

#ifdef DEBUGGING
#  define PRINT(fmt, ...) fprintf(stderr, fmt, ## __VA_ARGS__)
#else
#  define PRINT(fmt, ...)
#endif

// Function protos
// inline code definitions generated by software
static int _0000(void) {

        scan_index = 0;
        memset(buffer, 0, sizeof(buffer));
        buffer[scan_index++] = '{';
        buffer[scan_index++] = '{';

    return 0;
}

static int _0001(void) {

        scan_index = 0;
        memset(buffer, 0, sizeof(buffer));
        buffer[scan_index++] = '%';
        buffer[scan_index++] = '{';

    return 0;
}

// end of inline code definitions
#define func_to_strg(func) ( \
                   (func == Word)? "Word": \
                   (func == Squote)? "Squote": \
                   (func == Dquote)? "Dquote": \
                   (func == unexpected_ccurly)? "unexpected_ccurly": \
                   (func == RawBlock)? "RawBlock": \
                   (func == Sline)? "Sline": \
                   (func == Mline)? "Mline": \
                   (func == invalid_char)? "invalid_char": \
                   (func == InlineBlock)? "InlineBlock": \
                   (func == _0001)? "_0001": \
                   (func == _0000)? "_0000": \
                   (func == post_comment)? "post_comment": \
                   (func == unexpected_eof)? "unexpected_eof": \
                   (func == unexpected_newline)? "unexpected_newline": \
                   (func == init_copy)? "init_copy": \
                   (func == read_trans)? "read_trans": \
                   (func == pushback)? "pushback": \
                   (func == nop)? "nop": \
                   (func == copy_char)? "copy_char": \
 "UNKNOWN")

static int Word(void);
static int Squote(void);
static int Dquote(void);
static int Sline(void);
static int Mline(void);
static int InlineBlock(void);
static int RawBlock(void);
static int Scanner(void);


static int Word(void) {

    enum { START, END, ERROR, };

// INVALID, WHITE, ALPNUM, NEWLINE, PUNCT, SQCHAR, DQCHAR, PERCENT, SLASH, STAR, OCURLY, CCURLY, END_FILE,

    state_t states[1][13] = {
        {{END, pushback}, {END, nop}, {START, copy_char}, {END, nop}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, nop}}
    };
    init_copy();

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_trans();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int Squote(void) {

    enum { START, END, ERROR, };

// INVALID, WHITE, ALPNUM, NEWLINE, PUNCT, SQCHAR, DQCHAR, PERCENT, SLASH, STAR, OCURLY, CCURLY, END_FILE,

    state_t states[1][13] = {
        {{START, copy_char}, {START, copy_char}, {START, copy_char}, {ERROR, unexpected_newline}, {START, copy_char}, {END, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {ERROR, unexpected_eof}}
    };
    init_copy();

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_trans();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int Dquote(void) {

    enum { START, END, ERROR, };

// INVALID, WHITE, ALPNUM, NEWLINE, PUNCT, SQCHAR, DQCHAR, PERCENT, SLASH, STAR, OCURLY, CCURLY, END_FILE,

    state_t states[1][13] = {
        {{START, copy_char}, {START, copy_char}, {START, copy_char}, {ERROR, unexpected_newline}, {START, copy_char}, {START, copy_char}, {END, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {ERROR, unexpected_eof}}
    };
    init_copy();

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_trans();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int Sline(void) {

    enum { START, END, ERROR, };

// INVALID, WHITE, ALPNUM, NEWLINE, PUNCT, SQCHAR, DQCHAR, PERCENT, SLASH, STAR, OCURLY, CCURLY, END_FILE,

    state_t states[1][13] = {
        {{START, nop}, {START, nop}, {START, nop}, {END, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {END, nop}}
    };

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_trans();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    post_comment();
    return (state == END)? 0: -1;
}


static int Mline(void) {

    enum { START, HAVESTAR, END, ERROR, };

// INVALID, WHITE, ALPNUM, NEWLINE, PUNCT, SQCHAR, DQCHAR, PERCENT, SLASH, STAR, OCURLY, CCURLY, END_FILE,

    state_t states[2][13] = {
        {{START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {HAVESTAR, nop}, {START, nop}, {START, nop}, {ERROR, unexpected_eof}},
        {{START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {START, nop}, {END, nop}, {START, nop}, {START, nop}, {START, nop}, {ERROR, unexpected_eof}}
    };

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_trans();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    post_comment();
    return (state == END)? 0: -1;
}


static int InlineBlock(void) {

    enum { START, HAVECCURLY, END, ERROR, };

// INVALID, WHITE, ALPNUM, NEWLINE, PUNCT, SQCHAR, DQCHAR, PERCENT, SLASH, STAR, OCURLY, CCURLY, END_FILE,

    state_t states[2][13] = {
        {{START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {HAVECCURLY, copy_char}, {ERROR, unexpected_eof}},
        {{START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {END, copy_char}, {ERROR, unexpected_eof}}
    };
    _0000();

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_trans();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int RawBlock(void) {

    enum { START, DQUOTE, SQUOTE, HAVESTAR, SLINE, MLINE, HAVESLASH, HAVEPERCENT, END, ERROR, };

// INVALID, WHITE, ALPNUM, NEWLINE, PUNCT, SQCHAR, DQCHAR, PERCENT, SLASH, STAR, OCURLY, CCURLY, END_FILE,

    state_t states[8][13] = {
        {{START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {SQUOTE, copy_char}, {DQUOTE, copy_char}, {HAVEPERCENT, copy_char}, {HAVESLASH, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {ERROR, unexpected_eof}},
        {{DQUOTE, copy_char}, {DQUOTE, copy_char}, {DQUOTE, copy_char}, {DQUOTE, copy_char}, {DQUOTE, copy_char}, {DQUOTE, copy_char}, {START, copy_char}, {DQUOTE, copy_char}, {DQUOTE, copy_char}, {DQUOTE, copy_char}, {DQUOTE, copy_char}, {DQUOTE, copy_char}, {ERROR, unexpected_eof}},
        {{SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {START, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {SQUOTE, copy_char}, {ERROR, unexpected_eof}},
        {{MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {START, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {ERROR, unexpected_eof}},
        {{SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {START, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {SLINE, copy_char}, {ERROR, unexpected_eof}},
        {{MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {HAVESTAR, copy_char}, {MLINE, copy_char}, {MLINE, copy_char}, {ERROR, unexpected_eof}},
        {{START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {SLINE, copy_char}, {MLINE, copy_char}, {START, copy_char}, {START, copy_char}, {ERROR, unexpected_eof}},
        {{START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {START, copy_char}, {END, copy_char}, {ERROR, unexpected_eof}}
    };
    _0001();

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_trans();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int Scanner(void) {

    enum { START, HAVEOCURLY, HAVESLASH, HAVEPERCENT, SPECIAL, END, ERROR, };

// INVALID, WHITE, ALPNUM, NEWLINE, PUNCT, SQCHAR, DQCHAR, PERCENT, SLASH, STAR, OCURLY, CCURLY, END_FILE,

    state_t states[5][13] = {
        {{ERROR, invalid_char}, {START, nop}, {END, Word}, {START, nop}, {SPECIAL, copy_char}, {END, Squote}, {END, Dquote}, {HAVEPERCENT, copy_char}, {HAVESLASH, copy_char}, {SPECIAL, copy_char}, {HAVEOCURLY, copy_char}, {SPECIAL, copy_char}, {END, nop}},
        {{ERROR, invalid_char}, {END, nop}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, pushback}, {END, InlineBlock}, {END, pushback}, {END, nop}},
        {{ERROR, invalid_char}, {END, nop}, {END, pushback}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {END, pushback}, {SPECIAL, copy_char}, {START, Sline}, {START, Mline}, {END, pushback}, {END, pushback}, {END, nop}},
        {{ERROR, invalid_char}, {END, nop}, {END, pushback}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {SPECIAL, copy_char}, {END, RawBlock}, {ERROR, unexpected_ccurly}, {END, nop}},
        {{ERROR, invalid_char}, {END, nop}, {END, pushback}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {END, pushback}, {SPECIAL, copy_char}, {END, pushback}, {SPECIAL, copy_char}, {SPECIAL, copy_char}, {END, pushback}, {END, nop}}
    };

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_trans();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}



// End of generated code

// START OF GLOBAL INTERFACE

int init_scanner(void) {

    int i;

    for(i = 0; i < sizeof(char_table); i++)
        char_table[i] = INVALID;

    for(i = 0; stop[i] != 0; i++)
        char_table[(int)stop[i]] = WHITE;      // AKA whitespace

    for(i = 0; special[i] != 0; i++)
        char_table[(int)special[i]] = PUNCT;   // not stoppers or words

    for(i = 0; words[i] != 0; i++)
        char_table[(int)words[i]] = ALPNUM;       // not stoppers or special

    char_table['\"'] = DQCHAR;
    char_table['\''] = SQCHAR;
    char_table['%'] = PERCENT;
    char_table['/'] = SLASH;
    char_table['*'] = STAR;
    char_table['{'] = OCURLY;
    char_table['}'] = CCURLY;
    char_table['\n'] = NEWLINE;
    char_table[255] = END_FILE;

    return 0;
}

void destroy_scanner(void) {
    while(!files_close()) {/*empty*/;}
}

int scanner_open_file(char *name) {
    return files_open(name);
}

char *get_word(void) {
    memset(buffer, 0, sizeof(buffer));
    scan_index = 0;
    Scanner();  // this is the name of the primary state machine
    return buffer;
}

// END OF GLOBAL INTERFACE

#ifdef UNIT_TEST

int main(void) {

    init_scanner();

    scanner_open_file("Test-5.txt");

    while(strlen(get_word()) !=  0) {
        printf("word: %s: %d: %d: \"%s\"\n", file_name(), line_number(), strlen(buffer), buffer);
    }
    printf("\n%d lines, total\n", total_lines());


    return 0;
}

#endif
