

This is the definition for a state machine generator.  The state machine is
a full-featured implementation that supports the following features:

1.  Integer driven state machine.  The states and the state transitions are
    designated by numbers.  The input to the state machine is generated by a
    user-defined function that delivers the transitions on demand.  The output
    of each state is defined by user generated code that is implemented as
    inline functions that are optionaly called when a state change is
    identified.

2.  State machines can "call" one-another.  State machines are defined as
    discreet functions.  This allows for recursive state machines as well as
    causing any arbritrary code to be run as a result of a state transition.
    Note that state machines cannot "return" a state.  That would violate the
    input/output scenario indicated above.

3.  Input and output functions are defined on a per-state machine basis.  There
    is no requirement for a machine to use a certain input or output function
    but it is OK for that to happen.

4.  Very general design.  These state machines can be used for any application
    that lends its self to implementation using a state machine.  Applications
    can be as simple as a word scanner and as complex as a full featured
    language parser.

5.  Easily define and maintain complex machines by breaking them down into
    simpler parts that are easy to work with.  Definition files are stand-alone

6.  Re-targetability.  The state changes are emitted as simple tables that
    can be easily tweaked to work with any language. The sections of code that
    read and store a definition and the section that emits the output are
    totally separate and share only a single data strucutre.

---
Operation

The state machine is a very simple construct that has robust programming
capability. A state machine cannot exist without a stream of incomming data. It
reacts to that stream of data by changing its internal state and perhaps
producing some output when the stream of states indicate that it should.

There is a single input function that is implemented by the user for a given
state machine that accepts an arbritrary input and then returns unsigned
integers for the state transitions.

The output of the state machine is implemented by the user can can be any
arbritrary thing such as text or binary code. The output functions are called
when a state transition is made.

The state machine driver simply uses the generated tables to maintain state and
call the correct output function(s) when directed to do so.

---
Syntax of the definition file.

1.  The syntax is intended to be as simple as possible, but no simpler. C style
    single and mutiple line comments are supported.

2.  The "include" directive is supported. The include directive can only be used
    outside of a machine definition. Including a machine with the same name is a
    syntax error. The is no code in the state machine generator for mitigating
    name conflicts.

3.  The basic unit of definition is the machine. A machine defines a set of
    states and state transitions that are grouped together. A machine is similar
    in concept to a class, but it is not an object.

4.  The basic unit of definition of a machine is a state.

5.  A state is defined by it's state transitions.

A machine is in a particular state and it receives a transition. The transition
causes the machine to optionally change states and optionally execute arbritrary
code. So, a state is defined in terms of the transitions that it handles and a
state machine is defined in terms of the states that it can be in.

-------------
Reserved words and symbols

Note that all words and symbols are case sensitive. For example, the word
"Default" and the word "DEFAULT" are distinct.  The latter being a keyword.  The
parser for the state definition language is stupid in that it makes no attempt
to determine if someone is misusing a keyword or if there are duplicate symbols
and the like.  Those types of problems will be uncovered when trying to compile
the output.

include Cause another file to be loaded at the location where the inlcude
        statement is located.  When the new file is completed, then the
        old one picks up where it left off. Requires a quoted string. Cannot
        appear inside of a machine definition.

machine Introduces a machine definition. Followed by a name and a "{" symbol.

state   Introduces a state definition. Followed by a list of transitions. A
        transition consists of a list of transition names, separated by a "|"
        character and terminated by a ":" character. Following that is the name
        of the state that will be entered after the specified code has been
        executed. Note that machines do not share states.

START   Starting state. This is a system defined state and it must be defined
        as a state in the machine definition.

END     Indicates that the machine is to stop and return.  It is not permissable
        to define this state in the state machine, but it is the only way for
        the state machine to stop executing.

ERROR   The ERROR state stops the machine. It is provided to allow a
        generic error to be handled before the machine stops. Normally the user
        will define all error states by defining an error handler for the ERROR
        state.

DEFAULT Transitions that are not explicitly listed.  Similar to the "default:"
        clause in a switch/case.

states  Introduces the list of state symbols that will be used in the
        machine definition. By convention, these are all upper case words and
        are treated as "enum"s internally.

transitions Introduces the list of transtion symbols that will be used to
            implement the state machine.  These are treated as "enum"s
            internally.

input   Specify the name of the input function to the state machine.  This can
        be specified as a simple function name or as inline code. If it is
        defined as inline code it will not be visible to other machines. This
        may not be defined as a quoted string. It is defined as a simple
        function, then it must be visible at the global scope and may be defined
        as a static function.

pre_code    Code to run before the state machine states are begun. This may be
            defined as inline code or as a simple function.  If it is defined
            as inline code, it will not be visible to other state machines. If
            it is defined as a simple function, the function with the same name
            must be in the global scope. The function prototype is "void
            name(void)".  It may be defined as a static function, if
            appropraite.

post_code   Code to run after the state machine ends.  Can be a funciton name
            or an inline block.  Follows the same rules as the pre_code keyword.

;   Virtual line terminator.  Appears at the end of all statements, including
    directives and nested statements such as machine definitions.

{}  Encloses a block of scope for states and for machines.

""  Encloses a string.  Used for the include statement only.

,   Separates elements in a list.  Used in the states and transitions data
    only.

|   Read as "OR".  Separates alternative transitions in a state transition.

%{ %}   Encloses a preamble or a postamble block of code.  Everything inside
        is placed in the output file unaltered.

{{ }}   Encloses an inline block.  The function name and the definition in the
        generated source is handled automatically.  Used with code definitions
        inside the machine definition only.

--------
State machine names and scoping

State machines can call one another. States defined within them need not have
unique names as they are only visible to the machine that they are defined in.

States and transitions that are defined within a machine are local to that
machine. They cannot be exported becasue it does not make sense to have one
machine to use states or transitions from another machine. Note that the user
may define an input function that can be shared between machines and output
functions may be shared if they are defined in the preamble.

State names may be defined exactly once in a machine.  Defining it more than
once is a syntax error.

If there is more than one machine defined, and the same name is used more than
once, the definition of that name in generated code is not duplicated.  That
means that any given name in a set of state machines will have the same
numerical value in every machine.  The user does not have any control over the
actual number assigned to a name.

If a state machine is defined multiple times, then the state definitions and
declaration are added to the state as though they were defined in the same
block.  Name conflicts are dealt with accordingly.

----------
Table format

Each state machine generates a table of data that consists of a single row for
each state it defines and a column for each transition that is defined for the
machine. The states and the transitions are "enum"ed for each state funciton.
Each item in the table consists of a state and a function. The state is the next
state that the machine will have, after the function returns.  If the function
is the name of another state machine, then the state will be the state that the
machine takes after the other state machine has returned.

If the function definition is inline code, then the code is placed in it's own
funciton. The function name is a simple sequential number. The function has no
standard format except that it must return nothing and have no parameters.  This
can be easy to work around by using globals in the user code.
