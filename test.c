
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "parse.h"
#include "tokens.h"
#include "files.h"

/*
enum {
    PIPE_SYMBOL,
    OCURLY_SYMBOL,
    CCURLY_SYMBOL,
    CCURSEMI_SYMBOL,
    COMMA_SYMBOL,
    SEMI_SYMBOL,
    COLON_SYMBOL,
    INCLUDE_SYMBOL,
    MACHINE_SYMBOL,
    INPUT_SYMBOL,
    STATES_SYMBOL,
    TRANS_SYMBOL,
    STATE_SYMBOL,
    PRECODE_SYMBOL,
    POSTCODE_SYMBOL,
    QSTRG_SYMBOL,
    UNKNOWN_SYMBOL,
    FILE_END_SYMBOL,
    RAW_BLOCK,
    INLINE_BLOCK,
};
*/

struct token {
    char strg[1024*32];
    int type;
};

// these are used to construct the data strucutre as the parse evolves
static definition_t *def;
static state_list_t *sta;
static machine_t *mac;
static transition_t *tran;

int read_token(void) {

    token_t *tok = get_token();
    strncpy(token.strg, tok->strg, sizeof(token.strg));
    token.type = tok->type;
    free_token(tok;)
    return token.type;
}

static char *save_inline(char *str) {

    static int num = 100;
    char buffer[25];
    inline_list_t *inl = ALLOC(inline_list_t);

    snprintf(buffer, sizeof(buffer), "_inline_%04X", num);
    inl->name = STRDUP(buffer);
    inl->body = STRDUP(str);
    if(mac->list != NULL)
        inl->next = mac->list;
    mac->list = inl;
    return inl->name;
}

static int nop(void) {
    // simple as simple gets
    return 0;
}

static int unexpected_token(void) {
    ERROR(SYNTAX_ERROR, "Unexpected %s token encountered", tok->strg);
    return 0;
}

static int create_machine(void) {


    return 0;
}

static void validate_machine(void) {

    return 0;
}

/*******************************************************************************
*  Generated code below this point
******************************************************************************/

typedef struct {
    int state;
    int (*func)(void);
} state_t;

//#define DEBUGGING

#ifdef DEBUGGING
#  define PRINT(fmt, ...) fprintf(stderr, fmt, ## __VA_ARGS__)
#else
#  define PRINT(fmt, ...)
#endif

// Function protos
// inline code definitions generated by software
static int _0000(void) {

            files_open(token.strg);
        
    return 0;
}

static int _0001(void) {

            if(mac->postcode != NULL)
                SERROR(SYNTAX_ERROR, "Only one \"postcode\" directive is allowed per machine");
            else {
                char *name = save_inline(token.strg);
                mac->postcode = STRDUP(name);
            }
        
    return 0;
}

static int _0002(void) {

            if(mac->postcode != NULL)
                SERROR(SYNTAX_ERROR, "Only one \"postcode\" directive is allowed per machine");
            else
                mac->postcode = STRDUP(token.strg);
        
    return 0;
}

static int _0003(void) {

            if(mac->precode != NULL)
                SERROR(SYNTAX_ERROR, "Only one \"precode\" directive is allowed per machine");
            else {
                char *name = save_inline(token.strg);
                mac->precode = STRDUP(name);
            }
        
    return 0;
}

static int _0004(void) {

            if(mac->precode != NULL)
                SERROR(SYNTAX_ERROR, "Only one \"precode\" directive is allowed per machine");
            else
                mac->precode = STRDUP(token.strg);
        
    return 0;
}

static int _0005(void) {

            string_list_t *lst = ALLOC(string_list_t);
            lst->strg = STRDUP(token.strg);
            if(mac->trans != NULL)
                lst->next = mac->trans;
            mac->trans = lst;
        
    return 0;
}

static int _0006(void) {

            if(sta->list != NULL)
                tran->next = sta->list;
            sta->list = trans;
        
    return 0;
}

static int _0007(void) {

            char *name = save_inline(token.strg);
            tran->func = STRDUP(name);
        
    return 0;
}

static int _0008(void) {

            tran->func = STRDUP(token.strg);
        
    return 0;
}

static int _0009(void) {

            tran->state = STRDUP(token.strg);
        
    return 0;
}

static int _000A(void) {

            string_list_t *lst = ALLOC(string_list_t);
            lst->strg = STRDUP(token.strg);
            lst->next = trans->list
            tran->list = lst;
        
    return 0;
}

static int _000B(void) {

            tran = ALLOC(transition_t);
            tran->list = ALLOC(string_list_t);
            tran->list->strg = STRDUP(token.strg);
        
    return 0;
}

static int _000C(void) {

            sta->name = STRDUP(token.strg);
        
    return 0;
}

static int _000D(void) {

        sta = ALLOC(state_list_t);
    
    return 0;
}

static int _000E(void) {

        if(mac->list != NULL)
            sta->next = mac->list;
        mac->list = sta;
    
    return 0;
}

static int _000F(void) {

            string_list_t *lst = ALLOC(string_list_t);
            lst->strg = STRDUP(token.strg);
            if(mac->states != NULL)
                lst->next = mac->states;
            mac->states = lst;
        
    return 0;
}

static int _0010(void) {

            if(mac->input != NULL)
                SERROR(SYNTAX_ERROR, "Only one \"input\" directive is allowed per machine");
            else {
                char *name = save_inline(token.strg);
                mac->input = STRDUP(name);
            }
        
    return 0;
}

static int _0011(void) {

            if(mac->input != NULL)
                SERROR(SYNTAX_ERROR, "Only one \"input\" directive is allowed per machine");
            else
                mac->input = STRDUP(token.strg);
        
    return 0;
}

static int _0012(void) {

            mac->name = STRDUP(token.strg);
        
    return 0;
}

static int _0013(void) {

        mac = ALLOC(machine_t);
    
    return 0;
}

static int _0014(void) {

        if(def->machine_list != NULL)
            mac->next = def->machine_list;
        def->machine_list = mac;
    
    return 0;
}

static int _0015(void) {
 def = ALLOC(definition_t); 
    return 0;
}

static int _0016(void) {
 validate(def); 
    return 0;
}

// end of inline code definitions
#define func_to_strg(func) ( \
                   (func == _0016)? "_0016": \
                   (func == _0015)? "_0015": \
                   (func == Machine)? "Machine": \
                   (func == Include)? "Include": \
                   (func == _0014)? "_0014": \
                   (func == _0013)? "_0013": \
                   (func == _0012)? "_0012": \
                   (func == Input)? "Input": \
                   (func == StateList)? "StateList": \
                   (func == State)? "State": \
                   (func == TransList)? "TransList": \
                   (func == PreCode)? "PreCode": \
                   (func == PostCode)? "PostCode": \
                   (func == _0011)? "_0011": \
                   (func == _0010)? "_0010": \
                   (func == _000F)? "_000F": \
                   (func == _000E)? "_000E": \
                   (func == _000D)? "_000D": \
                   (func == _000C)? "_000C": \
                   (func == _000B)? "_000B": \
                   (func == _000A)? "_000A": \
                   (func == _0009)? "_0009": \
                   (func == _0008)? "_0008": \
                   (func == _0007)? "_0007": \
                   (func == _0006)? "_0006": \
                   (func == _0005)? "_0005": \
                   (func == _0004)? "_0004": \
                   (func == _0003)? "_0003": \
                   (func == _0002)? "_0002": \
                   (func == _0001)? "_0001": \
                   (func == nop)? "nop": \
                   (func == read_token)? "read_token": \
                   (func == _0000)? "_0000": \
                   (func == unexpected_token)? "unexpected_token": \
 "UNKNOWN")

static int Include(void);
static int PostCode(void);
static int PreCode(void);
static int TransList(void);
static int State(void);
static int StateList(void);
static int Input(void);
static int Machine(void);
static int Parse(void);


static int Include(void) {

    enum { START, END, ERROR, };

    state_t states[1][20] = {
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {END, _0000}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}}
    };

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_token();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int PostCode(void) {

    enum { START, HAVENAME, END, ERROR, };

    state_t states[2][20] = {
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {HAVENAME, _0002}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {HAVENAME, _0001}},
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {END, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}}
    };

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_token();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int PreCode(void) {

    enum { START, HAVENAME, END, ERROR, };

    state_t states[2][20] = {
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {HAVENAME, _0004}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {HAVENAME, _0003}},
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {END, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}}
    };

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_token();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int TransList(void) {

    enum { START, HAVENAME, END, ERROR, };

    state_t states[2][20] = {
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {HAVENAME, _0005}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}},
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {START, nop}, {END, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}}
    };

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_token();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int State(void) {

    enum { START, GETTAIL, GETSTATE, GETCODE, GETNAME, TRANSLIST, BODY, INTRO, END, ERROR, };

    state_t states[8][20] = {
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {INTRO, _000C}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}},
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {BODY, _0006}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}},
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {GETCODE, _0009}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}},
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {GETTAIL, _0008}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {GETTAIL, _0007}},
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {TRANSLIST, _000A}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}},
        {{GETNAME, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {GETSTATE, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}},
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {END, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {TRANSLIST, _000B}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}},
        {{ERROR, unexpected_token}, {BODY, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}}
    };
    _000D();

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_token();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    _000E();
    return (state == END)? 0: -1;
}


static int StateList(void) {

    enum { START, HAVENAME, END, ERROR, };

    state_t states[2][20] = {
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {HAVENAME, _000F}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}},
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {START, nop}, {END, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}}
    };

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_token();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int Input(void) {

    enum { START, END, ERROR, };

    state_t states[1][20] = {
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {HAVENAME, _0011}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {HAVENAME, _0010}}
    };

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_token();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    return (state == END)? 0: -1;
}


static int Machine(void) {

    enum { START, BODY, INTRO, END, ERROR, };

    state_t states[3][20] = {
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {INTRO, _0012}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}},
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {END, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {START, Input}, {START, StateList}, {START, TransList}, {START, State}, {START, PreCode}, {START, PostCode}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}},
        {{ERROR, unexpected_token}, {BODY, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}}
    };
    _0013();

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_token();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    _0014();
    return (state == END)? 0: -1;
}


static int Parse(void) {

    enum { START, END, ERROR, };

    state_t states[1][20] = {
        {{ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {START, Include}, {START, Machine}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {ERROR, unexpected_token}, {END, nop}, {ERROR, unexpected_token}, {ERROR, unexpected_token}}
    };
    _0015();

    int state = START;
    PRINT("\nSM %s() ENTER\n", __func__);
    do{
        int trans = read_token();
        PRINT("state = %d: trans = %d: char = '%c' (0x%02X) => func: %s state: %d\n",
                state, trans, (character == 0x0a)? ' ': character, character,
                func_to_strg(states[state][trans].func), states[state][trans].state);
        (*states[state][trans].func)();
        state = states[state][trans].state;
    }while(state != END && state != ERROR);
    PRINT("SM %s() RETURNING\n", __func__);

    _0016();
    return (state == END)? 0: -1;
}



// End of generated code
